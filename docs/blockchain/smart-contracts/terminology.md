# 专业术语

## gas
在合约中，你的用户每次执行你的dapp都需要执行一定的gas，gas可以用以太币购买，因此，用户每次跑dapp都得花费以太币。
一个dapp收取多少gas取决于功能逻辑的复杂程度。每个操作背后，都在计算完成这个操作所需要的计算资源，（比如，存储数据就比做个加法运算贵得多）， 一次操作所需要花费的 gas 等于这个操作背后的所有运算花销的总和。

由于运行你的程序需要花费用户的真金白银，在以太坊中代码的编程语言，比其他任何编程语言都更强调优化。同样的功能，使用笨拙的代码开发的程序，比起经过精巧优化的代码来，运行花费更高，这显然会给成千上万的用户带来大量不必要的开销。

### 为什么要用 gas 来驱动？
以太坊就像一个巨大、缓慢、但非常安全的电脑。当你运行一个程序的时候，网络上的每一个节点都在进行相同的运算，以验证它的输出 —— 这就是所谓的“去中心化” 由于数以千计的节点同时在验证着每个功能的运行，这可以确保它的数据不会被被监控，或者被刻意修改。

可能会有用户用无限循环堵塞网络，抑或用密集运算来占用大量的网络资源，为了防止这种事情的发生，以太坊的创建者为以太坊上的资源制定了价格，想要在以太坊上运算或者存储，你需要先付费。

### 节省gas的方法

**1、结构封装**

如果一个 `struct` 中有多个`uint`，则尽可能使用较小的 `uint`, Solidity 会将这些 `uint` 打包在一起，从而占用较少的存储空间

通过`Struct`将相同属性的变量放在一起，比如有``a,b,c``
三个变量，那么我们可以这样去定义：
```ts
Struct NormalMe {
  uint a;
  uint b;
  uint c; 
}

Struct MiniMe {
  uint32 a;
  uint32 b;
  uint; 
}

// 因为使用了结构打包，`mini` 比 `normal` 占用的空间更少
NormalMe normal = NormalMe(10, 20, 30);
MiniMe mini = MiniMe(10, 20, 30); 

```
所以，当 uint 定义在一个 `struct` 中的时候，尽量使用最小的整数子类型以节约空间。 并且把同样类型的变量放一起（即在 `struct` 中将把变量按照类型依次放置），这样 `Solidity` 可以将存储空间最小化。例如，有两个 struct：

``uint c; uint32 a; uint32 b; 和 uint32 a; uint c; uint32 b;``

前者比后者需要的gas更少，因为前者把uint32放一起了。

**2、利用`View`函数节省 Gas**

`view` 函数不花 `gas`,这是因为 `view` 函数不会真正改变区块链上的任何数据 - 它们只是读取。因此用 `view` 标记一个函数，意味着告诉 `web3.js`，运行这个函数只需要查询你的本地以太坊节点,而不需要在区块链上创建一个事务（事务需要运行在每个节点上，因此花费`gas`）

::: tip 注意
如果一个 view 函数在另一个函数的内部被调用，而调用函数与 view 函数的不属于同一个合约，也会产生调用成本。这是因为如果主调函数在以太坊创建了一个事务，它仍然需要逐个节点去验证。所以标记为 view 的函数只有在外部调用时才是免费的。
:::
     
## 侧链